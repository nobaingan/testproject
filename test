package com.example.demo.util;

import com.fasterxml.jackson.annotation.JsonFilter;
import com.fasterxml.jackson.databind.ser.FilterProvider;
import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;
import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Field;
import java.util.*;

public class DynamicFilterUtil {

    private static final Logger logger = LoggerFactory.getLogger(DynamicFilterUtil.class);

    /**
     * Creates a FilterProvider based on `includeOnly` and `excludeOnly` parameters.
     *
     * @param includeFields Fields to include explicitly (`includeOnly`).
     * @param excludeFields Fields to exclude explicitly (`excludeOnly`).
     * @param rootClass     The root class to process.
     * @return A configured FilterProvider for dynamic filtering.
     */
    public static FilterProvider createFilters(Set<String> includeFields, Set<String> excludeFields, Class<?> rootClass) {
        logger.info("Creating filters for root class: {}", rootClass.getSimpleName());
        logger.info("Include fields: {}", includeFields);
        logger.info("Exclude fields: {}", excludeFields);

        Map<String, Set<String>> filters = new HashMap<>();
        Set<Class<?>> visited = new HashSet<>();

        // Process fields with constraints
        processFields(includeFields, excludeFields, rootClass, "", filters, visited);

        logger.info("Generated filters: {}", filters);
        return buildFilterProvider(filters);
    }

    /**
     * Processes fields dynamically, restricting to classes with `@JsonFilter` annotation or specific packages (e.g., `.dto`).
     */
    private static void processFields(Set<String> includeFields, Set<String> excludeFields, Class<?> clazz,
                                      String prefix, Map<String, Set<String>> filters, Set<Class<?>> visited) {
        if (visited.contains(clazz)) {
            return; // Prevent infinite recursion
        }
        visited.add(clazz);

        if (!isRelevantClass(clazz)) {
            logger.debug("Skipping irrelevant class: {}", clazz.getName());
            return;
        }

        String filterName = clazz.getSimpleName() + "Filter";
        Set<String> relevantFields = new HashSet<>();
        logger.debug("Processing class: {}, Prefix: {}", clazz.getSimpleName(), prefix);

        for (Field field : clazz.getDeclaredFields()) {
            String fieldName = field.getName();
            String fullName = prefix.isEmpty() ? fieldName : prefix + "." + fieldName;

            boolean includeField = includeFields.isEmpty() || includeFields.contains(fullName) || includeFields.contains(prefix);
            boolean excludeField = excludeFields.contains(fullName) || excludeFields.contains(fieldName);

            if (includeField && !excludeField) {
                relevantFields.add(fieldName);
            }

            // Handle nested objects and collections
            if (!field.getType().isPrimitive() && !field.getType().equals(String.class)) {
                Class<?> fieldType = field.getType();

                // If the field is a collection, extract its generic type
                if (Collection.class.isAssignableFrom(fieldType)) {
                    fieldType = getCollectionElementType(field);
                }

                if (fieldType != null) {
                    processFields(includeFields, excludeFields, fieldType, fullName, filters, visited);

                    // Retain parent objects only if they have relevant nested fields
                    if (shouldRetainParent(includeFields, excludeFields, fullName)) {
                        relevantFields.add(fieldName);
                    }
                }
            }
        }

        filters.put(filterName, relevantFields);
        logger.info("Filter for class {}: {}", clazz.getSimpleName(), relevantFields);
    }

    private static Class<?> getCollectionElementType(Field field) {
        try {
            return (Class<?>) ((java.lang.reflect.ParameterizedType) field.getGenericType()).getActualTypeArguments()[0];
        } catch (Exception e) {
            logger.warn("Could not determine collection element type for field: {}", field.getName(), e);
            return null;
        }
    }

    /**
     * Determines if a class is relevant based on the presence of `@JsonFilter` or its package.
     *
     * @param clazz The class to evaluate.
     * @return True if the class is relevant, false otherwise.
     */
    private static boolean isRelevantClass(Class<?> clazz) {
        // Check for @JsonFilter annotation
        if (clazz.isAnnotationPresent(JsonFilter.class)) {
            return true;
        }

        // Restrict to classes in the `.dto` package
        String packageName = clazz.getPackage().getName();
        return packageName.contains(".dto");
    }

    /**
     * Determines if a parent object should be retained based on `includeOnly` or `excludeOnly`.
     */
    private static boolean shouldRetainParent(Set<String> includeFields, Set<String> excludeFields, String parentPath) {
        return includeFields.stream().anyMatch(field -> field.startsWith(parentPath + ".")) ||
                excludeFields.stream().anyMatch(field -> field.startsWith(parentPath + "."));
    }

    /**
     * Builds the FilterProvider from the filters map.
     */
    private static FilterProvider buildFilterProvider(Map<String, Set<String>> filters) {
        SimpleFilterProvider filterProvider = new SimpleFilterProvider();
        filters.forEach((className, fields) -> {
            SimpleBeanPropertyFilter filter = fields.isEmpty()
                    ? SimpleBeanPropertyFilter.filterOutAll()
                    : SimpleBeanPropertyFilter.filterOutAllExcept(fields);
            logger.debug("Adding filter for class: {}, Fields: {}", className, fields);
            filterProvider.addFilter(className, filter);
        });

        filterProvider.setFailOnUnknownId(false);
        return filterProvider;
    }
}


package com.example.demo.interceptor;

import com.example.demo.model.dto.AccountDetailsResponse;
import com.example.demo.util.DynamicFilterUtil;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ser.FilterProvider;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
@Component
public class DynamicFilterInterceptor implements HandlerInterceptor {

    private final ObjectMapper objectMapper;

    public DynamicFilterInterceptor(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String includeOnly = request.getParameter("includeOnly");
        String excludeOnly = request.getParameter("excludeOnly");

        Set<String> includeFields = includeOnly != null ? new HashSet<>(Arrays.asList(includeOnly.split(","))) : new HashSet<>();
        Set<String> excludeFields = excludeOnly != null ? new HashSet<>(Arrays.asList(excludeOnly.split(","))) : new HashSet<>();

        // Determine the response class dynamically
        Class<?> responseType = getResponseType(handler);
        if (responseType != null) {
            // Apply dynamic filters
            FilterProvider filters = DynamicFilterUtil.createFilters(includeFields, excludeFields, responseType);
            objectMapper.setFilterProvider(filters);
        }

        return true;
    }

    /**
     * Extracts the return type of the controller method dynamically.
     */
    private Class<?> getResponseType(Object handler) {
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            return handlerMethod.getMethod().getReturnType();
        }
        return null;
    }
}

package com.example.demo.interceptor;


import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    private final DynamicFilterInterceptor dynamicFilterInterceptor;

    public WebConfig(DynamicFilterInterceptor dynamicFilterInterceptor) {

        this.dynamicFilterInterceptor = dynamicFilterInterceptor;

    }

    public void addInterceptors (InterceptorRegistry registry) {

        registry.addInterceptor(dynamicFilterInterceptor).addPathPatterns("/accounts/**");

    }

    }

package com.example.demo.interceptor;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ObjectMapperConfig {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        // Add a default filter to prevent failures when no filter is found
        mapper.setFilterProvider(new SimpleFilterProvider().setFailOnUnknownId(false));
        return mapper;
    }
}

package com.example.demo.controller;

import com.example.demo.model.dto.AccountDetailsResponse;
import com.example.demo.model.dto.TransactionDetailsResponse;
import com.example.demo.service.AccountService;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/accounts")
@RequiredArgsConstructor
public class AccountController {

    private final AccountService accountService;

    @GetMapping(value = "/{accountNumber}", produces = MediaType.APPLICATION_JSON_VALUE)
    public AccountDetailsResponse getAccountDetails(@PathVariable String accountNumber,
                                                    @RequestParam(required = false) String includeOnly,
                                                    @RequestParam(required = false) String excludeOnly,
                                                    HttpServletRequest request) {
        AccountDetailsResponse accountDetailsResponse = accountService.getAccountDetails();
        //request.setAttribute("res");
        return accountDetailsResponse;
    }

    @GetMapping(value = "/transactions", produces = MediaType.APPLICATION_JSON_VALUE)
    public TransactionDetailsResponse getAccountTransactions(
                                                             @RequestParam(required = false) String includeOnly,
                                                             @RequestParam(required = false) String excludeOnly,
                                                             HttpServletRequest request) {
        TransactionDetailsResponse transactionDetailsResponse = accountService.getAccountTransactionDetails();
        //request.setAttribute("res");
        return transactionDetailsResponse;
    }



}

package com.example.demo.aspect;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.ProceedingJoinPoint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggingAspect {

    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

    // Log all method calls in the specified package
    @Around("execution(* com.example.demo..*(..))")
    public Object logMethodCall(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();

        logger.info("Entering method: {}.{}", className, methodName);
        logger.info("Arguments: {}", joinPoint.getArgs());

        long startTime = System.currentTimeMillis();

        try {
            Object result = joinPoint.proceed(); // Proceed with the intercepted method
            long elapsedTime = System.currentTimeMillis() - startTime;

            logger.info("Exiting method: {}.{}; Execution time: {} ms", className, methodName, elapsedTime);
            logger.info("Return Value: {}", result);

            return result;
        } catch (Exception ex) {
            logger.error("Exception in method: {}.{}; Message: {}", className, methodName, ex.getMessage(), ex);
            throw ex;
        }
    }

    // Log after successful method execution
    @AfterReturning(pointcut = "execution(* com.example.demo..*(..))", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        logger.info("Method {} executed successfully. Returned: {}", methodName, result);
    }

    // Log after exceptions are thrown
    @AfterThrowing(pointcut = "execution(* com.example.demo..*(..))", throwing = "exception")
    public void logAfterThrowing(JoinPoint joinPoint, Exception exception) {
        String methodName = joinPoint.getSignature().getName();
        logger.error("Exception thrown in method {}. Exception: {}", methodName, exception.getMessage());
    }
}
package com.example.demo.service;

import com.example.demo.model.dto.*;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class AccountService {

    public AccountDetailsResponse getAccountDetails() {
        return AccountDetailsResponse.builder()
                .account(AccountDetails.builder().accountId("1").accountName("Test").accountNumber("1234567890").build())
                .tmDetails(TMAccountDetails.builder().proprietary("proprietary").build())
                .build();
    }

    public TransactionDetailsResponse getAccountTransactionDetails() {
        return TransactionDetailsResponse.builder()
                .meta(Meta.builder().info("info").id("id").build())
                .transaction(List.of(Transaction.builder().accountName("1").accountNumber("1").build(), Transaction.builder().accountNumber("2").accountName("2").build()))
                .build();
    }
}


plugins {
	id 'java'
	id 'org.springframework.boot' version '3.4.3'
	id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(17)
	}
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

repositories {
	mavenCentral()
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-web-services'
	implementation 'com.fasterxml.jackson.core:jackson-databind'
	implementation 'org.springframework.boot:spring-boot-starter-validation'
	implementation 'jakarta.servlet:jakarta.servlet-api:6.0.0' // Use the latest version
	implementation 'org.springframework.boot:spring-boot-starter-aop'

	compileOnly 'org.projectlombok:lombok'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.named('test') {
	useJUnitPlatform()
}


//application.prop
spring.application.name=demo
server.error.whitelabel.enabled=false
server.error.path=/error
logging.level.root=INFO
logging.level.com.example.demo=DEBUG
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n


Here‚Äôs a **Confluence page draft** for documenting the recent changes:  

---

# **Validation Enhancements for `includeOnly` and `excludeOnly` Query Parameters**

## **Overview**

To enhance the security and integrity of our application, we‚Äôve introduced validation logic for the `includeOnly` and `excludeOnly` query parameters across relevant API endpoints. These parameters allow clients to filter response fields dynamically, but they pose a risk if not properly validated.

This document outlines the validation logic implemented, the need for sanitized query parameters, and the reasons behind these changes.

---

## **Why Validation is Necessary**

Query parameters like `includeOnly` and `excludeOnly` are powerful for optimizing API responses by controlling which fields are included or excluded. However, they present potential vulnerabilities if not handled carefully:

### **1. Security Risks:**
- **Cross-Site Scripting (XSS)**: Malicious scripts could be injected via query parameters, leading to unauthorized data access or script execution in clients.
- **Injection Attacks**: Invalid characters might be used to manipulate query behavior or execute unintended operations.

### **2. Data Integrity:**
Invalid or malformed field names may cause unpredictable API behavior or runtime errors, affecting the system's reliability.

### **3. Consistency:**
By enforcing consistent validation logic across endpoints, the application‚Äôs behavior becomes predictable and easier to maintain.

---

## **Validation Logic**

The validation logic is centralized to maintain consistency and avoid redundancy across multiple endpoints.

### **Key Validation Rules:**

1. **Exclusive Parameter Usage:**
   - **Rule**: Only one of `includeOnly` or `excludeOnly` can be used in a single request.
   - **Reason**: Using both can cause ambiguity in filtering logic and lead to inconsistent API responses.
   - **Response**: Returns HTTP **400 Bad Request** with a descriptive error message.

2. **Allowed Characters Check:**
   - **Rule**: Field names can only contain:
     - Letters (`a-zA-Z`)
     - Numbers (`0-9`)
     - Underscores (`_`)
     - Dots (`.`) for nested fields
   - **Reason**: Restricts XSS and injection attacks by allowing only safe characters.
   - **Response**: HTTP **400 Bad Request** with a message indicating invalid characters.

3. **Valid Nested Field Format:**
   - **Rule**: Nested fields (e.g., `account.accountName`) are allowed and should be validated correctly.
   - **Reason**: Ensures nested structures are handled consistently and securely.

4. **Error Handling:**
   - All validation failures result in HTTP **400 Bad Request**, providing clients with actionable feedback.

---

## **Implementation Details**

The validation logic is implemented in the `FieldValidatorUtil` class and applied globally via interceptors:

### **FieldValidatorUtil.java**

```java
public class FieldValidatorUtil {
    
    private static final Pattern VALID_FIELD_PATTERN = Pattern.compile("^[a-zA-Z0-9_.]+$");

    public static void validateParams(Set<String> includeFields, Set<String> excludeFields) {
        if (includeFields != null && excludeFields != null && !includeFields.isEmpty() && !excludeFields.isEmpty()) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, 
                "Invalid request: You cannot use both 'includeOnly' and 'excludeOnly' at the same time.");
        }

        validateFieldFormat(includeFields, "includeOnly");
        validateFieldFormat(excludeFields, "excludeOnly");
    }

    private static void validateFieldFormat(Set<String> fields, String paramName) {
        if (fields == null) return;

        for (String field : fields) {
            if (!VALID_FIELD_PATTERN.matcher(field).matches()) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, 
                    "Invalid field in '" + paramName + "': " + field + 
                    ". Allowed characters: letters, numbers, underscores (_), and dots (.) for nesting.");
            }
        }
    }
}
```

### **Interceptor Integration:**
The `DynamicFilterInterceptor` invokes this validation before processing the request:

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    Set<String> includeFields = parseParameter(request.getParameter("includeOnly"));
    Set<String> excludeFields = parseParameter(request.getParameter("excludeOnly"));

    FieldValidatorUtil.validateParams(includeFields, excludeFields);

    // Filter creation logic here...
    return true;
}

private Set<String> parseParameter(String param) {
    return param == null ? Collections.emptySet() : new HashSet<>(Arrays.asList(param.split(",")));
}
```

---

## **Benefits of Validation:**

### **1. Enhanced Security:**
- Prevents XSS and injection attacks.
- Blocks unsafe characters.

### **2. Consistent API Behavior:**
- Clear rules across all endpoints.
- Better client experience with precise error feedback.

### **3. Improved Data Integrity:**
- Avoids malformed requests from causing runtime errors or inconsistencies.

### **4. Maintainability:**
- Centralized logic via `FieldValidatorUtil`, reducing code duplication and simplifying future changes.

---

## **Conclusion**

By introducing robust validation for the `includeOnly` and `excludeOnly` query parameters, we ensure the security, consistency, and reliability of our API responses. This change mitigates potential attacks while improving data integrity and maintainability.

For further details or to discuss improvements, please contact the API development team.

---
Here's a complete overview of all possible approaches to validating query parameters (`includeOnly` and `excludeOnly`) in a Spring Boot application. I'll provide a high-level summary and a full implementation of each approach, followed by a decision matrix comparing them.  

---

# **üîç Overview of Approaches**  

### ‚úÖ **1. Annotation-Based Approach (`@RequestParam` + Validation Annotations)**
- Uses **Spring‚Äôs built-in validation** annotations like `@Pattern`.
- Simple and easy to implement.
- Not reusable across multiple controllers.

### ‚úÖ **2. DTO-Based Approach (`@Valid QueryParamsDTO`)**
- Defines a separate DTO (`Data Transfer Object`) for query parameters.
- Uses **Bean Validation** (`@Pattern`, `@AssertTrue`).
- Works well with **Swagger** and ensures cleaner controllers.

### ‚úÖ **3. Interceptor-Based Approach (`HandlerInterceptor`)**
- Applies **global** validation before reaching controllers.
- Great for enforcing rules across multiple endpoints.
- Not visible in **Swagger**, making debugging harder.

### ‚úÖ **4. AOP-Based Approach (`@Aspect`)**
- Uses **Aspect-Oriented Programming (AOP)** to validate query parameters.
- **Non-intrusive**, meaning it doesn‚Äôt modify controllers directly.
- Centralized validation logic across multiple endpoints.

---

# **1Ô∏è‚É£ Annotation-Based Approach**  
### üìå **Implementation**
```java
import jakarta.validation.constraints.Pattern;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class QueryParamController {

    @GetMapping("/data")
    public String getData(
        @RequestParam(value = "includeOnly", required = false) 
        @Pattern(regexp = "^[a-zA-Z0-9.]+$", message = "Invalid includeOnly format") String includeOnly,

        @RequestParam(value = "excludeOnly", required = false) 
        @Pattern(regexp = "^[a-zA-Z0-9.]+$", message = "Invalid excludeOnly format") String excludeOnly
    ) {
        if (includeOnly != null && excludeOnly != null) {
            throw new IllegalArgumentException("Only one of 'includeOnly' or 'excludeOnly' should be provided.");
        }
        return "Validated Query Params";
    }
}
```

### üü¢ **Pros**
- Simple, minimal code.
- Works **out-of-the-box** with Spring validation.
- No extra classes required.

### üî¥ **Cons**
- **Duplicate logic** if used in multiple controllers.
- No centralized validation.

---

# **2Ô∏è‚É£ DTO-Based Approach**
### üìå **Implementation**
#### Step 1: Define DTO  
```java
import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.Pattern;

public class QueryParamsDTO {

    @Pattern(regexp = "^[a-zA-Z0-9.]+$", message = "Invalid includeOnly format")
    private String includeOnly;

    @Pattern(regexp = "^[a-zA-Z0-9.]+$", message = "Invalid excludeOnly format")
    private String excludeOnly;

    @AssertTrue(message = "Only one of 'includeOnly' or 'excludeOnly' should be provided.")
    public boolean isValid() {
        return includeOnly == null || excludeOnly == null;
    }

    // Getters and Setters
}
```

#### Step 2: Use in Controller  
```java
@RestController
@RequestMapping("/api")
public class QueryParamController {

    @GetMapping("/data")
    public String getData(@Valid QueryParamsDTO queryParams) {
        return "Validated Query Params: " + queryParams;
    }
}
```

### üü¢ **Pros**
- **Clean controller code**.
- Centralized validation in DTO.
- Works **well with Swagger**.

### üî¥ **Cons**
- Requires **additional class (DTO)**.
- Can feel unnecessary for simple APIs.

---

# **3Ô∏è‚É£ Interceptor-Based Approach**
### üìå **Implementation**
#### Step 1: Create an Interceptor  
```java
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
public class QueryParamsInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String includeOnly = request.getParameter("includeOnly");
        String excludeOnly = request.getParameter("excludeOnly");

        if (includeOnly != null && excludeOnly != null) {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Only one of 'includeOnly' or 'excludeOnly' should be provided.");
            return false;
        }

        if ((includeOnly != null && !includeOnly.matches("^[a-zA-Z0-9.]+$")) ||
            (excludeOnly != null && !excludeOnly.matches("^[a-zA-Z0-9.]+$"))) {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid characters in query parameters.");
            return false;
        }

        return true;
    }
}
```

#### Step 2: Register the Interceptor  
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private QueryParamsInterceptor queryParamsInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(queryParamsInterceptor);
    }
}
```

### üü¢ **Pros**
- **Applies globally** without modifying controllers.
- Useful for **cross-cutting concerns** like security.

### üî¥ **Cons**
- **Not visible in Swagger**.
- **More setup required** than annotations.

---

# **4Ô∏è‚É£ AOP-Based Approach**
### üìå **Implementation**
#### Step 1: Create a Custom Annotation  
```java
import jakarta.validation.Constraint;
import jakarta.validation.Payload;
import java.lang.annotation.*;

@Documented
@Constraint(validatedBy = IncludeExcludeValidator.class)
@Target({ ElementType.PARAMETER, ElementType.FIELD })
@Retention(RetentionPolicy.RUNTIME)
public @interface ValidIncludeExclude {
    String message() default "Invalid includeOnly/excludeOnly parameter";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

#### Step 2: Implement AOP Validation  
```java
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.JoinPoint;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class QueryParamsValidationAspect {

    @Before("execution(* com.example.controller.*.*(..)) && args(includeOnly, excludeOnly, ..)")
    public void validateQueryParams(JoinPoint joinPoint, String includeOnly, String excludeOnly) {
        if (includeOnly != null && excludeOnly != null) {
            throw new IllegalArgumentException("Only one of 'includeOnly' or 'excludeOnly' should be provided.");
        }
        if ((includeOnly != null && !includeOnly.matches("^[a-zA-Z0-9.]+$")) ||
            (excludeOnly != null && !excludeOnly.matches("^[a-zA-Z0-9.]+$"))) {
            throw new IllegalArgumentException("Invalid characters in includeOnly/excludeOnly");
        }
    }
}
```

### üü¢ **Pros**
- **Non-intrusive**, doesn‚Äôt modify controllers.
- **Works globally** across multiple controllers.

### üî¥ **Cons**
- **More complex to debug**.
- **Not beginner-friendly**.

---

# **üìä Decision Matrix**
| Approach | Best For | Pros | Cons |
|----------|---------|------|------|
| **Annotation-Based** | Simple APIs | Easy to implement, No extra classes | Not reusable |
| **DTO-Based** | APIs with Swagger | Clean code, Works well with `@Valid` | Extra class needed |
| **Interceptor-Based** | Global validation | Applies validation to all controllers | Not visible in Swagger |
| **AOP-Based** | Cross-cutting concerns | No changes in controllers, Reusable | More complex to debug |

### **üèÜ Which One to Choose?**
- ‚úÖ **For simplicity ‚Üí Annotation-Based**
- ‚úÖ **For Swagger support ‚Üí DTO-Based**
- ‚úÖ **For global enforcement ‚Üí Interceptor**
- ‚úÖ **For non-intrusive validation ‚Üí AOP-Based**

--------------------------------------
Yes! The validation can be dynamic based on the response structure. Instead of hardcoding valid fields, you can extract them dynamically from your actual response data. Here‚Äôs how you can do it across different approaches:  

---

## **üîπ Dynamic Validation Based on Response**
### **1Ô∏è‚É£ How It Works**
- Instead of a **static list** (`VALID_FIELDS`), fetch valid fields **dynamically** from the API response structure.
- Extract keys dynamically from a **JSON Schema**, a **Database**, or a **Service Layer**.
- This ensures that if the response format changes, the validation updates automatically.

---

## **üîπ Dynamic Approach Implementation**
### **üî∏ Step 1: Create a Utility to Extract Allowed Fields**
```java
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class ResponseSchemaValidator {

    public static Set<String> extractValidFields(Map<String, Object> responseData) {
        return responseData.keySet();  // Extract top-level keys
    }

    public static Set<String> extractNestedFields(Map<String, Object> responseData, String key) {
        Object value = responseData.get(key);
        if (value instanceof Map) {
            return ((Map<String, Object>) value).keySet().stream()
                .map(subKey -> key + "." + subKey)  // Format as "transactions.details"
                .collect(Collectors.toSet());
        }
        return Set.of(); // No nested fields
    }
}
```

-------------------

## **üîπ Approach 1: Dynamic DTO Validation**
### **Modify Validator to Use Dynamic Schema**
```java
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class DynamicFieldValidator implements ConstraintValidator<ValidField, String> {

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) return true;  // Optional parameter
        
        Map<String, Object> mockResponse = getMockApiResponse(); // Fetch API response
        Set<String> validFields = ResponseSchemaValidator.extractValidFields(mockResponse);
        Set<String> validNestedFields = validFields.stream()
            .flatMap(key -> ResponseSchemaValidator.extractNestedFields(mockResponse, key).stream())
            .collect(Collectors.toSet());

        return validFields.contains(value) || validNestedFields.contains(value);
    }

    private Map<String, Object> getMockApiResponse() {
        // Simulating an API response structure dynamically
        Map<String, Object> mockResponse = new HashMap<>();
        mockResponse.put("transactions", Map.of("details", "some details"));
        mockResponse.put("balances", Map.of("summary", "balance summary"));
        mockResponse.put("fees", "fee details");
        return mockResponse;
    }
}
```

---

Yes, you already have three approaches:  

1. **Annotation-based approach** (directly using `@RequestParam` with `@Pattern`)  
2. **Custom DTO approach** (`@Valid QueryParamsDTO` with `@Pattern` and `@AssertTrue`)  
3. **Interceptor-based approach** (handling validation globally via `HandlerInterceptor`)  

### üîç **What Other Approaches Exist?**  

#### **4. AOP (Aspect-Oriented Programming) Approach**  
You can use **Spring AOP** to create a validation aspect that runs **before** the controller method executes. This ensures that **all request methods using `includeOnly` and `excludeOnly`** automatically get validated.

---

### ‚úÖ **AOP-Based Validation Approach**
üìå **Step 1: Create a Custom Annotation**  
```java
import jakarta.validation.Constraint;
import jakarta.validation.Payload;
import java.lang.annotation.*;

@Documented
@Constraint(validatedBy = IncludeExcludeValidator.class)
@Target({ ElementType.PARAMETER, ElementType.FIELD })
@Retention(RetentionPolicy.RUNTIME)
public @interface ValidIncludeExclude {
    String message() default "Invalid includeOnly/excludeOnly parameter";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

üìå **Step 2: Create the Validator Class**  
```java
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

public class IncludeExcludeValidator implements ConstraintValidator<ValidIncludeExclude, String> {
    
    private static final String VALID_PATTERN = "^[a-zA-Z0-9.]+$";
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        return value == null || value.matches(VALID_PATTERN);
    }
}
```

üìå **Step 3: Create an Aspect for Validation**  
```java
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.JoinPoint;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class QueryParamsValidationAspect {

    @Before("execution(* com.example.controller.*.*(..)) && args(includeOnly, excludeOnly, ..)")
    public void validateQueryParams(JoinPoint joinPoint, String includeOnly, String excludeOnly) {
        if (includeOnly != null && excludeOnly != null) {
            throw new IllegalArgumentException("Only one of 'includeOnly' or 'excludeOnly' should be provided.");
        }
        if ((includeOnly != null && !includeOnly.matches("^[a-zA-Z0-9.]+$")) ||
            (excludeOnly != null && !excludeOnly.matches("^[a-zA-Z0-9.]+$"))) {
            throw new IllegalArgumentException("Invalid characters in includeOnly/excludeOnly");
        }
    }
}
```

üìå **Step 4: Use It in Your Controller**  
```java
@GetMapping("/data")
public String getData(
    @ValidIncludeExclude
    @RequestParam(value = "includeOnly", required = false) String includeOnly,

    @ValidIncludeExclude
    @RequestParam(value = "excludeOnly", required = false) String excludeOnly
) {
    return "Validated Query Params";
}
```

----------------------

Yes, ideally it **should fail** because of the invalid query parameter `y`. Since `y` is not defined in your controller method, Spring should automatically reject the request or ignore the unknown parameter. However, here‚Äôs what actually happens:

### Expected Behavior:
1. If `@ValidQueryParam` is correctly applied, **the validation should fail** if `includeOnly=test` violates the regex rules.
2. **The query parameter `y` is undefined** in your controller, so:
   - Spring **ignores it** by default (it doesn't trigger an error).
   - If you want it to fail when an unexpected query parameter is present, you'd need additional logic to strictly enforce allowed parameters.

### How to Make It Fail for Unexpected Query Parameters:
If you want strict validation where **ONLY** the expected parameters (`includeOnly`, `excludeOnly`) are allowed, you can:
‚úÖ **Manually validate request parameters in your controller** by checking `request.getParameterMap()`.  
‚úÖ **Use a whitelist approach** by rejecting any unknown keys.  
‚úÖ **Apply custom logic** that checks all provided parameters against the expected list.

Example:

```java
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.util.Set;

@RestController
@RequestMapping("/accounts")
public class AccountController {

    private static final Set<String> ALLOWED_PARAMS = Set.of("includeOnly", "excludeOnly");

    @GetMapping("/{accountNumber}")
    public AccountDetailsResponse getAccountDetails(
        @PathVariable String accountNumber,
        @Valid @ValidQueryParam @RequestParam(required = false) String includeOnly,
        @Valid @ValidQueryParam @RequestParam(required = false) String excludeOnly,
        HttpServletRequest request) {

        // Strictly enforce allowed query parameters
        for (String param : request.getParameterMap().keySet()) {
            if (!ALLOWED_PARAMS.contains(param)) {
                throw new IllegalArgumentException("Unexpected query parameter: " + param);
            }
        }

        return accountService.getAccountDetails();
    }

    @ExceptionHandler(IllegalArgumentException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public String handleUnexpectedParams(IllegalArgumentException ex) {
        return ex.getMessage();
    }
}
```

### üí° Summary:
- Spring **ignores unknown query parameters by default** unless you enforce strict validation.
- **Apply a whitelist check** for expected parameters to block unexpected ones.
- **Modify the validator** if you want a stricter policy.

Would you like me to refine this approach further for your needs?

--------------------------------------

### üî• **Comparison of All 4 Approaches**
| Approach | Pros | Cons |
|----------|------|------|
| **Annotation-Based (`@RequestParam`)** | Simple, No DTO required, Works with Swagger | Cannot reuse logic, Duplicates validation |
| **DTO-Based (`QueryParamsDTO`)** | Clean & Reusable, Works well with Swagger, Centralized validation | Requires extra class |
| **Interceptor-Based** | Global control, Can apply logic across multiple controllers | Slightly complex, Not visible in Swagger |
| **AOP-Based** | Centralized, No controller modification required, Works dynamically | Requires Aspect knowledge, Harder to debug |

---

### üöÄ **Final Thoughts**  
If you want **Swagger support + best maintainability**, go with **DTO-based validation**.  
If you need **global control**, use the **Interceptor** approach.  
If you prefer **clean controllers without modifying them**, **AOP-based validation** is a good choice.  

Would you like a more detailed implementation of any specific approach? üòä
